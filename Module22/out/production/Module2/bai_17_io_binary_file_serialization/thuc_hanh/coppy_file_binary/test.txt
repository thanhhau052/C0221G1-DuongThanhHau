In this Java File IO tutorial, we show you how to read and write binary files using both legacy File I/O API and new File I/O API (NIO). The legacy API (classes in the java.io.* package) is perfect for manipulating low-level binary I/O operations such as reading and writing exactly one byte at a time, whereas the NIO API (classes in the java.nio.* package) is more convenient for reading and writing the whole file at once, and of course, faster than the old File I/O API.

1. Understanding Byte Streams
We use byte streams to read and write data in binary format, exactly 8-bit bytes. All byte stream classes are descended from the abstract classes InputStream and OutputStream. The following class diagram depicts the main classes in the legacy File I/O API that are designed for working with binary files:
Byte Streams API
You can notice that these classes implement the AutoCloseable interface, which means that we can use the try-with-resources structure to close these streams automatically.
At the top of the hierarchy, the abstract class InputStream defines two primary methods for reading bytes from an input stream:
read(): reads one byte of data, returns the byte as an integer value. Return -1 if the end of the file is reached.
read(byte[]): reads a chunk of bytes to the specified byte array, up to the size of the array. This method returns -1 if thereâ€™s no more data or the end of the file is reached.

Similarly, the abstract class OutputStream defines two primary methods for writing bytes to an output stream:
write(int): writes the specified byte to the output stream.
write(byte[]): writes the specified array of bytes to the output stream